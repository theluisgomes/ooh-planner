// ============================================
// GLOBAL STATE
// ============================================
const API_BASE = 'http://localhost:3000/api';

// ============================================
// HELPERS
// ============================================
function createBlockState(id) {
    return {
        id: id,
        active: false,
        budget: null,              // NEW: Primary input
        campaignCycle: null,       // NEW: Secondary input
        filters: {                 // Now optional
            uf: 'Tudo',
            praca: 'Tudo',
            taxonomia: 'Tudo',
            exibidores: 'Tudo',
            formato: 'Tudo',
            digital: false,
            estatico: false
        },
        optimizationResult: null   // NEW: Replaces 'result'
    };
}

function getBlockById(id) {
    return state.mediaBlocks.find(b => b.id === Number(id));
}

function addBlock() {
    const newId = state.nextBlockId++;
    const newBlock = createBlockState(newId);
    state.mediaBlocks.push(newBlock);
    renderMediaBlocks();
}

function removeBlock(blockId) {
    // Se for o √∫ltimo bloco, apenas reseta
    if (state.mediaBlocks.length <= 1) {
        resetBlock(blockId);
        return;
    }

    if (!confirm('Tem certeza que deseja remover este recorte de m√≠dia?')) return;

    state.mediaBlocks = state.mediaBlocks.filter(b => b.id !== Number(blockId));
    renderMediaBlocks();
    updateConsolidated();
}

const state = {
    filters: {},
    pracaToUfMap: {},  // Mapeamento de pra√ßa para UF
    nextBlockId: 2, // ID counter for new blocks
    mediaBlocks: [createBlockState(1)]
};

// ============================================
// INITIALIZATION
// ============================================
document.addEventListener('DOMContentLoaded', async () => {
    console.log('üöÄ Inicializando OOH Planner...');

    try {
        // Setup event listeners
        setupEventListeners();

        // Carregar filtros dispon√≠veis
        await loadFilters();

        // Renderizar blocos iniciais
        renderMediaBlocks();

        console.log('‚úÖ Aplica√ß√£o inicializada com sucesso!');
    } catch (err) {
        console.error('‚ùå Erro ao inicializar:', err);
        showError('Erro ao inicializar aplica√ß√£o. Verifique se o servidor est√° rodando.');
    }
});

// ============================================
// API CALLS
// ============================================
async function loadFilters() {
    try {
        const response = await fetch(`${API_BASE}/filters`);
        if (!response.ok) throw new Error('Erro ao carregar filtros');

        state.filters = await response.json();

        // Construir mapeamento de pra√ßa para UF
        await buildPracaToUfMap();

        console.log('üìã Filtros carregados:', state.filters);
        console.log('üó∫Ô∏è  Mapeamento Pra√ßa‚ÜíUF:', state.pracaToUfMap);
    } catch (err) {
        console.error('Erro ao carregar filtros:', err);
        throw err;
    }
}

/**
 * Constr√≥i um mapeamento de pra√ßa para UF consultando o invent√°rio
 */
async function buildPracaToUfMap() {
    try {
        // Buscar dados do invent√°rio para criar o mapeamento
        const response = await fetch(`${API_BASE}/inventory`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ filters: {} })
        });

        if (!response.ok) return;

        const inventory = await response.json();

        // Criar mapeamento √∫nico de pra√ßa ‚Üí UF
        const map = {};
        inventory.forEach(item => {
            if (item.praca && item.uf) {
                // Normalizar para lowercase para compara√ß√£o case-insensitive
                const pracaKey = item.praca.toLowerCase();
                if (!map[pracaKey]) {
                    map[pracaKey] = item.uf;
                }
            }
        });

        state.pracaToUfMap = map;
    } catch (err) {
        console.error('Erro ao construir mapeamento pra√ßa‚ÜíUF:', err);
    }
}

async function optimizeBudget(blockId) {
    const block = getBlockById(blockId);

    // Don't calculate if primary inputs are missing
    if (!block.budget || !block.campaignCycle) {
        block.optimizationResult = null;
        block.active = false;
        updateBlockUI(blockId);
        return;
    }

    try {
        const response = await fetch(`${API_BASE}/optimize-budget`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                budget: block.budget,
                campaignCycle: block.campaignCycle,
                filters: block.filters
            })
        });

        if (!response.ok) throw new Error('Erro ao otimizar budget');

        const result = await response.json();
        block.optimizationResult = result;
        block.active = result.status !== 'error';

        updateBlockUI(blockId);
        updateConsolidated();

    } catch (err) {
        console.error(`Erro ao otimizar budget do bloco ${blockId}:`, err);
        block.optimizationResult = { status: 'error', message: 'Erro de conex√£o' };
        block.active = false;
        updateBlockUI(blockId);
    }
}

// ============================================
// UI GENERATION
// ============================================
function renderMediaBlocks() {
    const container = document.getElementById('mediaBlocks');
    const template = document.getElementById('mediaBlockTemplate');
    container.innerHTML = '';

    state.mediaBlocks.forEach((blockState, index) => {
        const clone = template.content.cloneNode(true);
        const block = clone.querySelector('.media-block');
        block.dataset.blockId = blockState.id;

        // Atualizar n√∫mero do bloco (visual sequencial)
        clone.querySelector('.number-badge').textContent = index + 1;
        clone.querySelector('.config-label').textContent = `CONFIGURA√á√ÉO T√âCNICA #${String(index + 1).padStart(2, '0')}`;

        // Preencher filtros
        populateFilters(block, blockState.id);

        // Restore static filters (Digital/Estatico checkboxes)
        const digitalCheckbox = block.querySelector('.filter-digital-checkbox');
        if (digitalCheckbox) {
            digitalCheckbox.checked = blockState.filters.digital === true;
        }

        const estaticoCheckbox = block.querySelector('.filter-estatico-checkbox');
        if (estaticoCheckbox) {
            estaticoCheckbox.checked = blockState.filters.estatico === true;
        }

        // Restore budget and campaign cycle values
        if (blockState.budget) block.querySelector('.input-budget').value = blockState.budget;
        if (blockState.campaignCycle) block.querySelector('.input-campaign-cycle').value = blockState.campaignCycle;

        // Event listeners
        setupBlockListeners(block, blockState.id);

        // Se j√° tiver resultado, atualizar UI
        if (blockState.optimizationResult) updateBlockUI(blockState.id);

        container.appendChild(clone);
    });
}

function populateFilters(blockElement, blockId, availableFilters = null) {
    const filtersToPopulate = ['uf', 'praca', 'taxonomia', 'exibidores', 'formato'];
    const currentFilters = getBlockById(blockId).filters;
    const sourceFilters = availableFilters || state.filters;

    filtersToPopulate.forEach(filterName => {
        const select = blockElement.querySelector(`.filter-${filterName}`);
        if (!select) return;

        const currentValue = currentFilters[filterName];

        // Limpar op√ß√µes exceto "Tudo"
        select.innerHTML = '<option value="Tudo">Tudo</option>';

        const options = sourceFilters[filterName] || [];
        options.forEach(val => {
            const option = document.createElement('option');
            option.value = val;
            option.textContent = val;
            select.appendChild(option);
        });

        // Check if current value exists in options
        if (currentValue && currentValue !== 'Tudo' && !options.includes(currentValue)) {
            // Force add the value if it's missing (keeps UI consistent with state)
            const option = document.createElement('option');
            option.value = currentValue;
            option.textContent = currentValue;
            select.appendChild(option);
        }

        // Always restore the proper value
        if (currentValue) {
            select.value = currentValue;
        } else {
            select.value = 'Tudo';
        }
    });
}

/**
 * Atualiza os filtros dispon√≠veis baseado nas sele√ß√µes atuais do bloco
 */
async function updateAvailableFilters(blockId) {
    const block = getBlockById(blockId);
    const blockElement = document.querySelector(`[data-block-id="${blockId}"]`);
    if (!blockElement) return;

    try {
        const response = await fetch(`${API_BASE}/filters/available`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ filters: block.filters })
        });

        if (!response.ok) throw new Error('Erro ao buscar filtros dispon√≠veis');

        const availableFilters = await response.json();

        // Atualiza o UI sem disparar novos eventos de change (populateFilters faz isso)
        populateFilters(blockElement, blockId, availableFilters);

    } catch (err) {
        console.error(`Erro ao atualizar filtros para bloco ${blockId}:`, err);
    }
}

// ============================================
// EVENT LISTENERS
// ============================================
function setupBlockListeners(blockElement, blockId) {
    // Primary inputs: Budget and Campaign Cycle
    const budgetInput = blockElement.querySelector('.input-budget');
    budgetInput.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        getBlockById(blockId).budget = isNaN(value) ? null : value;
        optimizeBudget(blockId);
    });

    const cycleInput = blockElement.querySelector('.input-campaign-cycle');
    cycleInput.addEventListener('input', (e) => {
        const value = parseInt(e.target.value);
        getBlockById(blockId).campaignCycle = isNaN(value) ? null : value;
        optimizeBudget(blockId);
    });

    // Optional Filters (selects)
    const selectFilters = ['uf', 'praca', 'taxonomia', 'exibidores', 'formato'];
    selectFilters.forEach(filterName => {
        const select = blockElement.querySelector(`.filter-${filterName}`);
        if (select) {
            select.addEventListener('change', (e) => {
                getBlockById(blockId).filters[filterName] = e.target.value;

                // Se mudou a pra√ßa, atualizar UF automaticamente (especial)
                if (filterName === 'praca' && e.target.value !== 'Tudo') {
                    const pracaKey = e.target.value.toLowerCase();
                    const correspondingUf = state.pracaToUfMap[pracaKey];

                    if (correspondingUf) {
                        getBlockById(blockId).filters.uf = correspondingUf;
                    }
                }

                // Atualiza filtros dispon√≠veis para os OUTROS campos
                updateAvailableFilters(blockId);

                // Re-optimize with new filters
                optimizeBudget(blockId);
            });
        }
    });

    // Optional Filters (checkboxes) - Digital and Est√°tico
    const digitalCheckbox = blockElement.querySelector('.filter-digital-checkbox');
    if (digitalCheckbox) {
        digitalCheckbox.addEventListener('change', (e) => {
            getBlockById(blockId).filters.digital = e.target.checked;
            optimizeBudget(blockId);
        });
    }

    const estaticoCheckbox = blockElement.querySelector('.filter-estatico-checkbox');
    if (estaticoCheckbox) {
        estaticoCheckbox.addEventListener('change', (e) => {
            getBlockById(blockId).filters.estatico = e.target.checked;
            optimizeBudget(blockId);
        });
    }

    // Bot√£o delete (remove bloco)
    const deleteBtn = blockElement.querySelector('.btn-delete');
    deleteBtn.addEventListener('click', () => removeBlock(blockId));
}

function setupEventListeners() {
    // Reset All
    document.getElementById('btnResetAll').addEventListener('click', resetAll);

    // Export
    document.getElementById('btnExport').addEventListener('click', exportCSV);

    // Config (placeholder)
    document.getElementById('btnConfig').addEventListener('click', () => {
        alert('Configura√ß√µes em desenvolvimento');
    });

    // Store to BigQuery
    document.getElementById('btnStore').addEventListener('click', storeToBigQuery);
}

// ============================================
// UI UPDATES
// ============================================
function updateBlockUI(blockId) {
    const block = getBlockById(blockId);
    const blockElement = document.querySelector(`[data-block-id="${blockId}"]`);
    if (!blockElement) return;

    const statusBadge = blockElement.querySelector('.status-badge');
    const resultsSection = blockElement.querySelector('.budget-results-section');
    const messageDiv = blockElement.querySelector('.block-message');

    // Hide results if no optimization
    if (!block.optimizationResult || block.optimizationResult.status === 'error') {
        // Estado de erro ou inativo
        if (statusBadge) {
            statusBadge.textContent = 'INATIVO';
            statusBadge.classList.add('inactive');
            statusBadge.classList.remove('active');
        }

        if (resultsSection) resultsSection.style.display = 'none';

        if (block.optimizationResult?.message) {
            messageDiv.textContent = block.optimizationResult.message;
            messageDiv.className = 'block-message error';
            messageDiv.style.display = 'block';
        } else {
            messageDiv.style.display = 'none';
        }
        return;
    }

    // Show active state
    if (statusBadge) {
        statusBadge.textContent = 'ATIVO';
        statusBadge.classList.remove('inactive');
        statusBadge.classList.add('active');
    }

    // Show results section
    if (resultsSection) resultsSection.style.display = 'block';

    const result = block.optimizationResult;

    // Update status indicator
    const statusMessageMain = blockElement.querySelector('.status-message-main');
    const statusIndicatorMain = blockElement.querySelector('.status-indicator-main');

    if (statusMessageMain && statusIndicatorMain) {
        statusMessageMain.textContent = result.statusMessage || '--';

        // Apply status classes
        statusIndicatorMain.classList.remove('status-ok', 'status-warning', 'status-info');
        if (result.status === 'sufficient') {
            statusIndicatorMain.classList.add('status-ok');
        } else if (result.status === 'insufficient') {
            statusIndicatorMain.classList.add('status-warning');
        } else if (result.status === 'excessive') {
            statusIndicatorMain.classList.add('status-info');
        }
    }

    // Update metrics
    const facesCount = blockElement.querySelector('.faces-count');
    const idealBudget = blockElement.querySelector('.ideal-budget');
    const allocatedBudget = blockElement.querySelector('.allocated-budget');
    const remainingBudget = blockElement.querySelector('.remaining-budget');

    if (facesCount) facesCount.textContent = result.facesCount || 0;
    if (idealBudget) idealBudget.textContent = formatCurrency(result.idealBudget);
    if (allocatedBudget) allocatedBudget.textContent = formatCurrency(result.allocatedBudget);
    if (remainingBudget) remainingBudget.textContent = formatCurrency(result.remainingBudget);

    // Update priority table
    updatePriorityTable(blockElement, result.recommendedFaces || []);

    // Hide message if success
    messageDiv.style.display = 'none';
}

/**
 * Update priority table with recommended faces
 */
function updatePriorityTable(blockElement, faces) {
    const tbody = blockElement.querySelector('.priority-list-body');
    if (!tbody) return;

    tbody.innerHTML = '';

    if (faces.length === 0) {
        tbody.innerHTML = '<tr><td colspan="9" style="text-align: center; padding: 2rem; opacity: 0.6;">Nenhuma face alocada</td></tr>';
        return;
    }

    // Show top 10 faces
    const displayFaces = faces.slice(0, 10);

    displayFaces.forEach((face) => {
        const row = document.createElement('tr');

        // Apply priority styling (top 3)
        if (face.priority === 1) row.classList.add('priority-gold');
        if (face.priority === 2) row.classList.add('priority-silver');
        if (face.priority === 3) row.classList.add('priority-bronze');

        row.innerHTML = `
            <td><strong>${face.priority}</strong></td>
            <td>${face.praca || '--'}</td>
            <td>${face.uf || '--'}</td>
            <td>${face.exibidores || '--'}</td>
            <td>${face.formato || '--'}</td>
            <td>${face.quantity || 0}</td>
            <td>${formatCurrency(face.unitPrice)}</td>
            <td><strong>${formatCurrency(face.totalCost)}</strong></td>
            <td><span class="roi-badge">${face.roi}</span></td>
        `;
        tbody.appendChild(row);
    });

    // Show total count if more than 10
    if (faces.length > 10) {
        const moreRow = document.createElement('tr');
        moreRow.innerHTML = `<td colspan="9" style="text-align: center; padding: 1rem; background: #f3f4f6; font-style: italic;">+ ${faces.length - 10} faces adicionais...</td>`;
        tbody.appendChild(moreRow);
    }
}

function updateConsolidated() {
    // Atualizar Total Card
    const activeBlocks = state.mediaBlocks.filter(b => b.active && b.optimizationResult?.allocatedBudget);
    const totalCard = activeBlocks.reduce((sum, b) => sum + b.optimizationResult.allocatedBudget, 0);

    document.getElementById('totalCard').textContent = formatCurrency(totalCard);

    // Atualizar tabela consolidada
    const tbody = document.getElementById('consolidatedTableBody');
    tbody.innerHTML = '';

    if (activeBlocks.length === 0) {
        tbody.innerHTML = '<tr class="empty-state"><td colspan="12">Nenhuma m√≠dia configurada ainda</td></tr>';
    } else {
        activeBlocks.forEach(block => {
            const result = block.optimizationResult;
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>M√≠dia ${block.id}</td>
                <td>${block.filters.uf}</td>
                <td>${block.filters.praca}</td>
                <td>${block.filters.taxonomia}</td>
                <td>${block.filters.exibidores}</td>
                <td>${block.filters.formato}</td>
                <td>${result.facesCount || 0}</td>
                <td>${formatCurrency(block.budget)}</td>
                <td>${formatCurrency(result.allocatedBudget)}</td>
                <td>${formatCurrency(result.idealBudget)}</td>
                <td>${formatCurrency(result.remainingBudget)}</td>
                <td><span class="status-badge">${result.status === 'sufficient' ? '‚úÖ' : result.status === 'insufficient' ? '‚ö†Ô∏è' : 'üí°'}</span></td>
            `;
            tbody.appendChild(row);
        });
    }
}

// Removed old indicator functions - no longer needed with budget-first approach

// ============================================
// ACTIONS
// ============================================
function resetBlock(blockId) {
    const block = getBlockById(blockId);
    const blockElement = document.querySelector(`[data-block-id="${blockId}"]`);

    // Reset state
    block.budget = null;
    block.campaignCycle = null;
    block.filters = {
        uf: 'Tudo',
        praca: 'Tudo',
        taxonomia: 'Tudo',
        exibidores: 'Tudo',
        formato: 'Tudo',
        digital: false,
        estatico: false
    };
    block.optimizationResult = null;
    block.active = false;

    // Reset UI
    blockElement.querySelectorAll('select').forEach(select => select.value = 'Tudo');
    blockElement.querySelectorAll('input').forEach(input => {
        input.value = '';
    });

    updateBlockUI(blockId);
    updateConsolidated();
}

function resetAll() {
    if (!confirm('Tem certeza que deseja resetar tudo? Isso remover√° todos os blocos.')) return;

    state.mediaBlocks = [createBlockState(1)];
    state.nextBlockId = 2;
    renderMediaBlocks();
    updateConsolidated();
}

async function storeToBigQuery() {
    const activeBlocks = state.mediaBlocks.filter(b => b.active && b.result?.total_liquido);

    if (activeBlocks.length === 0) {
        alert('‚ùå Nenhuma m√≠dia configurada para armazenar');
        return;
    }

    const totalBudget = activeBlocks.reduce((sum, b) => sum + b.result.total_liquido, 0);

    // Confirm with user
    const message = `Deseja armazenar ${activeBlocks.length} blocos de m√≠dia no BigQuery?\n\nTotal Budget: ${formatCurrency(totalBudget)}`;
    if (!confirm(message)) return;

    // Show loading state
    const btnStore = document.getElementById('btnStore');
    const originalText = btnStore.innerHTML;
    btnStore.innerHTML = '‚è≥ ARMAZENANDO...';
    btnStore.disabled = true;

    try {
        const response = await fetch(`${API_BASE}/bigquery/store`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                activeBlocks,
                totalBudget
            })
        });

        const result = await response.json();

        if (result.success) {
            alert(`‚úÖ Dados armazenados com sucesso no BigQuery!\n\nSession ID: ${result.sessionId}\nBlocos: ${result.rowsInserted}\nTimestamp: ${new Date(result.timestamp).toLocaleString('pt-BR')}`);
        } else {
            throw new Error(result.error || 'Erro desconhecido');
        }

    } catch (error) {
        console.error('Erro ao armazenar no BigQuery:', error);

        let errorMessage = '‚ùå Erro ao armazenar dados no BigQuery\n\n';

        if (error.message.includes('key file not found')) {
            errorMessage += 'Arquivo de credenciais n√£o encontrado.\nVerifique se o arquivo bigquery-key.json est√° na pasta config/';
        } else if (error.message.includes('Permission denied')) {
            errorMessage += 'Permiss√£o negada.\nVerifique as permiss√µes da Service Account.';
        } else if (error.message.includes('not found')) {
            errorMessage += 'Dataset ou tabela n√£o encontrada.\nVerifique a configura√ß√£o do BigQuery.';
        } else {
            errorMessage += error.message;
        }

        alert(errorMessage);
    } finally {
        // Restore button state
        btnStore.innerHTML = originalText;
        btnStore.disabled = false;
    }
}


// ============================================
// UTILITIES
// ============================================
function formatCurrency(value) {
    if (value === null || value === undefined) return '--';
    return new Intl.NumberFormat('pt-BR', {
        style: 'currency',
        currency: 'BRL'
    }).format(value);
}

function showError(message) {
    alert(message);
}
function exportCSV() {
    const activeBlocks = state.mediaBlocks.filter(b => b.active && b.optimizationResult);

    if (activeBlocks.length === 0) {
        alert('Nenhuma m√≠dia configurada para exportar');
        return;
    }

    // ===== PARTE 1: RESUMO DOS BLOCOS =====
    const summaryHeaders = ['M√≠dia', 'Budget Input', 'Ciclo (semanas)', 'UF', 'Pra√ßa', 'Taxonomia', 'Exibidores', 'Formato', 'Digital', 'Est√°tico', 'Faces Alocadas', 'Budget Utilizado', 'Budget Ideal', 'Sobrando', 'Status'];
    const summaryRows = activeBlocks.map(block => [
        `M√≠dia ${block.id}`,
        formatCurrency(block.budget),
        block.campaignCycle,
        block.filters.uf || 'Tudo',
        block.filters.praca || 'Tudo',
        block.filters.taxonomia || 'Tudo',
        block.filters.exibidores || 'Tudo',
        block.filters.formato || 'Tudo',
        block.filters.digital ? 'Sim' : 'N√£o',
        block.filters.estatico ? 'Sim' : 'N√£o',
        block.optimizationResult.facesCount || 0,
        formatCurrency(block.optimizationResult.allocatedBudget || 0),
        formatCurrency(block.optimizationResult.idealBudget || 0),
        formatCurrency(block.optimizationResult.remainingBudget || 0),
        block.optimizationResult.budgetStatus || block.optimizationResult.status || '-'
    ]);

    // ===== PARTE 2: DETALHES DAS FACES RECOMENDADAS =====
    const detailsHeaders = ['M√≠dia', 'Prioridade', 'Pra√ßa', 'UF', 'Exibidores', 'Taxonomia', 'Formato', 'Qtd Dispon√≠vel', 'Pre√ßo Unit√°rio', 'ROI', 'Alocado'];
    const detailsRows = [];

    activeBlocks.forEach(block => {
        const recommendedFaces = block.optimizationResult.recommendedFaces || [];
        recommendedFaces.forEach((face, index) => {
            detailsRows.push([
                `M√≠dia ${block.id}`,
                face.priority || (index + 1),
                face.praca || '-',
                face.uf || '-',
                face.exibidores || '-',
                face.taxonomia || '-',
                face.formato || '-',
                face.quantity || 0,
                formatCurrency(face.unitPrice || 0),
                (parseFloat(face.roi) || 0).toFixed(4),
                face.allocated || 0
            ]);
        });
    });

    // ===== GERAR CSV COMPLETO =====
    let csv = '';

    // Se√ß√£o 1: Resumo
    csv += '=== RESUMO DOS BLOCOS DE M√çDIA ===\n';
    csv += [summaryHeaders, ...summaryRows]
        .map(row => row.map(cell => `"${cell}"`).join(','))
        .join('\n');

    csv += '\n\n';

    // Se√ß√£o 2: Detalhes das Faces
    if (detailsRows.length > 0) {
        csv += '=== FACES RECOMENDADAS (DETALHADO) ===\n';
        csv += [detailsHeaders, ...detailsRows]
            .map(row => row.map(cell => `"${cell}"`).join(','))
            .join('\n');
    }

    // Download
    const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' }); // BOM for Excel UTF-8
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
    link.setAttribute('href', url);
    link.setAttribute('download', `plano_ooh_${timestamp}.csv`);
    link.style.visibility = 'hidden';

    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    // Delay revocation to allow download to start
    setTimeout(() => URL.revokeObjectURL(url), 100);

    console.log(`‚úÖ CSV exportado: ${activeBlocks.length} blocos, ${detailsRows.length} faces detalhadas`);
}

